package ca.ubc.stat.blang.tests.generate

import ca.ubc.stat.blang.tests.BlangDslInjectorProvider
import com.google.inject.Inject
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.TemporaryFolder
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.xbase.compiler.CompilationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(BlangDslInjectorProvider)
class SupportFactorGeneratorTest {
    @Inject public TemporaryFolder temporaryFolder
    @Inject extension CompilationTestHelper
    
    @Test
    def void supportFactor() {
        '''
            import ca.ubc.stat.blang.tests.types.Real
            
            model {
                param Real variance
                
                laws {
                    indicator(variance) = variance.doubleValue > 0
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.Model;
        import blang.core.ModelComponent;
        import blang.core.Param;
        import blang.core.SupportFactor;
        import ca.ubc.stat.blang.tests.types.Real;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.function.Supplier;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          @Param
          private final Supplier<Real> $generated__variance;
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with with BlangVariable annotation
           *   - params have @Param also
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@Param @DeboxedName("variance") final Supplier<Real> $generated__variance) {
            this.$generated__variance = $generated__variance;
          }
          
          /**
           * Auxiliary method generated to translate:
           * variance.doubleValue > 0 }
           */
          private static Boolean $generated__0(final Real variance) {
            double _doubleValue = variance.doubleValue();
            return Boolean.valueOf((_doubleValue > 0));
          }
          
          /**
           * Auxiliary method generated to translate:
           * variance.doubleValue > 0 }
           */
          private static SupportFactor $generated__0_lazy(final Supplier<Real> $generated__variance) {
            return new SupportFactor(() -> $generated__0($generated__variance.get()));
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            { // Code generated by: (variance) = variance.doubleValue > 0 }
              // Construction and addition of the factor/model:
              components.add(
                $generated__0_lazy($generated__variance)
              );
            }
            
            return components;
          }
        }
        '''
        )
    }
    
    
    @Test
    def void supportFactorRandom() {
        '''
            model {
                random java.util.Random rand
                
                laws {
                    indicator(rand) = rand.nextBoolean()
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.Model;
        import blang.core.ModelComponent;
        import blang.core.SupportFactor;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.Random;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          private final Random rand;
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with with BlangVariable annotation
           *   - params have @Param also
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@DeboxedName("rand") final Random rand) {
            this.rand = rand;
          }
          
          /**
           * Auxiliary method generated to translate:
           * rand.nextBoolean() }
           */
          private static Boolean $generated__0(final Random rand) {
            return Boolean.valueOf(rand.nextBoolean());
          }
          
          /**
           * Auxiliary method generated to translate:
           * rand.nextBoolean() }
           */
          private static SupportFactor $generated__0_lazy(final Random rand) {
            return new SupportFactor(() -> $generated__0(rand));
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            { // Code generated by: (rand) = rand.nextBoolean() }
              // Construction and addition of the factor/model:
              components.add(
                $generated__0_lazy(rand)
              );
            }
            
            return components;
          }
        }
        '''
        )
    }
    
    
    @Test
    def void supportFactorMultiParam() {
        '''
            import ca.ubc.stat.blang.tests.types.Real
            
            model {
                param Real mean

                param Real variance
                
                laws {
                    indicator(mean, variance) = { mean.doubleValue > 0.5 && variance.doubleValue > 0 }
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.Model;
        import blang.core.ModelComponent;
        import blang.core.Param;
        import blang.core.SupportFactor;
        import ca.ubc.stat.blang.tests.types.Real;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.function.Supplier;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          @Param
          private final Supplier<Real> $generated__mean;
          
          @Param
          private final Supplier<Real> $generated__variance;
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with with BlangVariable annotation
           *   - params have @Param also
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@Param @DeboxedName("mean") final Supplier<Real> $generated__mean, @Param @DeboxedName("variance") final Supplier<Real> $generated__variance) {
            this.$generated__mean = $generated__mean;
            this.$generated__variance = $generated__variance;
          }
          
          /**
           * Auxiliary method generated to translate:
           * { mean.doubleValue > 0.5 && variance.doubleValue > 0 }
           */
          private static Boolean $generated__0(final Real mean, final Real variance) {
            return Boolean.valueOf(((mean.doubleValue() > 0.5) && (variance.doubleValue() > 0)));
          }
          
          /**
           * Auxiliary method generated to translate:
           * { mean.doubleValue > 0.5 && variance.doubleValue > 0 }
           */
          private static SupportFactor $generated__0_lazy(final Supplier<Real> $generated__mean, final Supplier<Real> $generated__variance) {
            return new SupportFactor(() -> $generated__0($generated__mean.get(), $generated__variance.get()));
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            { // Code generated by: (mean, variance) = { mean.doubleValue > 0.5 && variance.doubleValue > 0 }
              // Construction and addition of the factor/model:
              components.add(
                $generated__0_lazy($generated__mean, $generated__variance)
              );
            }
            
            return components;
          }
        }
        '''
        )
    }
}