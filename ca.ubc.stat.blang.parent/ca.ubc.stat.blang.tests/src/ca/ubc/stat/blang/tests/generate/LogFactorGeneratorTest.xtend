package ca.ubc.stat.blang.tests.generate

import ca.ubc.stat.blang.tests.BlangDslInjectorProvider
import com.google.inject.Inject
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.TemporaryFolder
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.xbase.compiler.CompilationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(BlangDslInjectorProvider)
class LogFactorGeneratorTest {
    @Inject public TemporaryFolder temporaryFolder
    @Inject extension CompilationTestHelper        
    
    @Test
    def void logFactor() {
        '''
            import blang.core.RealVar
            
            model {
                param RealVar variance
                
                // TODO: const double LOG2PI = Math.log(2 * Math.PI)
                laws {
                    logf(variance) { -0.5 * ( Math.log(variance.doubleValue) + /* LOG2PI */ Math.log(2 * Math.PI) ) }
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.LogScaleFactor;
        import blang.core.Model;
        import blang.core.ModelBuilder;
        import blang.core.ModelComponent;
        import blang.core.Param;
        import blang.core.RealVar;
        import blang.inits.Arg;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.function.Supplier;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          public static class Builder implements ModelBuilder {
            @Arg
            public RealVar variance;
            
            public MyFile build() {
              // For each optional type, either get the value, or evaluate the ?: expression
              final RealVar __variance = variance;
              // Build the instance after boxing params
              return new MyFile(
                () -> __variance
              );
            }
          }
          
          @Param
          private final Supplier<RealVar> $generated__variance;
          
          public RealVar getVariance() {
            return $generated__variance.get();
          }
          
          /**
           * Auxiliary method generated to translate:
           * { -0.5 * ( Math.log(variance.doubleValue) + Math.log(2 * Math.PI) ) }
           */
          private static Double $generated__0(final RealVar variance) {
            double _doubleValue = variance.doubleValue();
            double _log = Math.log(_doubleValue);
            double _log_1 = Math.log((2 * Math.PI));
            double _plus = (_log + _log_1);
            return Double.valueOf(((-0.5) * _plus));
          }
          
          /**
           * Auxiliary method generated to translate:
           * { -0.5 * ( Math.log(variance.doubleValue) + Math.log(2 * Math.PI) ) }
           */
          private static LogScaleFactor $generated__0_lazy(final Supplier<RealVar> $generated__variance) {
            return () -> $generated__0($generated__variance.get());
          }
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with a BlangVariable annotation
           *   - params additionally have a Param annotation
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@Param @DeboxedName("variance") final Supplier<RealVar> $generated__variance) {
            this.$generated__variance = $generated__variance;
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            { // Code generated by: (variance) { -0.5 * ( Math.log(variance.doubleValue) + Math.log(2 * Math.PI) ) }
              // Construction and addition of the factor/model:
              components.add(
                $generated__0_lazy($generated__variance)
              );
            }
            
            return components;
          }
        }
        '''
        )
    }
    
    
    @Test
    def void logFactorMultiParam() {
        '''
            import blang.core.RealVar
            
            model {
                param RealVar mean
                
                param RealVar variance
                
                laws {
                    logf(variance, mean) { -0.5 * mean.doubleValue / variance.doubleValue }
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.LogScaleFactor;
        import blang.core.Model;
        import blang.core.ModelBuilder;
        import blang.core.ModelComponent;
        import blang.core.Param;
        import blang.core.RealVar;
        import blang.inits.Arg;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.function.Supplier;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          public static class Builder implements ModelBuilder {
            @Arg
            public RealVar mean;
            
            @Arg
            public RealVar variance;
            
            public MyFile build() {
              // For each optional type, either get the value, or evaluate the ?: expression
              final RealVar __mean = mean;
              final RealVar __variance = variance;
              // Build the instance after boxing params
              return new MyFile(
                () -> __mean, 
                () -> __variance
              );
            }
          }
          
          @Param
          private final Supplier<RealVar> $generated__mean;
          
          public RealVar getMean() {
            return $generated__mean.get();
          }
          
          @Param
          private final Supplier<RealVar> $generated__variance;
          
          public RealVar getVariance() {
            return $generated__variance.get();
          }
          
          /**
           * Auxiliary method generated to translate:
           * { -0.5 * mean.doubleValue / variance.doubleValue }
           */
          private static Double $generated__0(final RealVar variance, final RealVar mean) {
            double _doubleValue = mean.doubleValue();
            double _multiply = ((-0.5) * _doubleValue);
            double _doubleValue_1 = variance.doubleValue();
            return Double.valueOf((_multiply / _doubleValue_1));
          }
          
          /**
           * Auxiliary method generated to translate:
           * { -0.5 * mean.doubleValue / variance.doubleValue }
           */
          private static LogScaleFactor $generated__0_lazy(final Supplier<RealVar> $generated__variance, final Supplier<RealVar> $generated__mean) {
            return () -> $generated__0($generated__variance.get(), $generated__mean.get());
          }
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with a BlangVariable annotation
           *   - params additionally have a Param annotation
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@Param @DeboxedName("mean") final Supplier<RealVar> $generated__mean, @Param @DeboxedName("variance") final Supplier<RealVar> $generated__variance) {
            this.$generated__mean = $generated__mean;
            this.$generated__variance = $generated__variance;
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            { // Code generated by: (variance, mean) { -0.5 * mean.doubleValue / variance.doubleValue }
              // Construction and addition of the factor/model:
              components.add(
                $generated__0_lazy($generated__variance, $generated__mean)
              );
            }
            
            return components;
          }
        }
        '''
        )
    }
    
    
    @Test
    def void logScaleFactorMultiVar() {
        '''
            import blang.core.RealVar
            
            model {
                param RealVar mean

                param RealVar variance
                
                random RealVar x
                
                laws {
                    logf(x, mean, variance) {
                        -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue
                    }
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.LogScaleFactor;
        import blang.core.Model;
        import blang.core.ModelBuilder;
        import blang.core.ModelComponent;
        import blang.core.Param;
        import blang.core.RealVar;
        import blang.inits.Arg;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.function.Supplier;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          public static class Builder implements ModelBuilder {
            @Arg
            public RealVar mean;
            
            @Arg
            public RealVar variance;
            
            @Arg
            public RealVar x;
            
            public MyFile build() {
              // For each optional type, either get the value, or evaluate the ?: expression
              final RealVar __mean = mean;
              final RealVar __variance = variance;
              final RealVar __x = x;
              // Build the instance after boxing params
              return new MyFile(
                __x, 
                () -> __mean, 
                () -> __variance
              );
            }
          }
          
          @Param
          private final Supplier<RealVar> $generated__mean;
          
          public RealVar getMean() {
            return $generated__mean.get();
          }
          
          @Param
          private final Supplier<RealVar> $generated__variance;
          
          public RealVar getVariance() {
            return $generated__variance.get();
          }
          
          private final RealVar x;
          
          public RealVar getX() {
            return x;
          }
          
          /**
           * Auxiliary method generated to translate:
           * { -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue }
           */
          private static Double $generated__0(final RealVar x, final RealVar mean, final RealVar variance) {
            double _doubleValue = x.doubleValue();
            double _doubleValue_1 = mean.doubleValue();
            double _minus = (_doubleValue - _doubleValue_1);
            double _multiply = ((-0.5) * _minus);
            double _power = Math.pow(_multiply, 2);
            double _doubleValue_2 = variance.doubleValue();
            return Double.valueOf((_power / _doubleValue_2));
          }
          
          /**
           * Auxiliary method generated to translate:
           * { -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue }
           */
          private static LogScaleFactor $generated__0_lazy(final RealVar x, final Supplier<RealVar> $generated__mean, final Supplier<RealVar> $generated__variance) {
            return () -> $generated__0(x, $generated__mean.get(), $generated__variance.get());
          }
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with a BlangVariable annotation
           *   - params additionally have a Param annotation
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@DeboxedName("x") final RealVar x, @Param @DeboxedName("mean") final Supplier<RealVar> $generated__mean, @Param @DeboxedName("variance") final Supplier<RealVar> $generated__variance) {
            this.$generated__mean = $generated__mean;
            this.$generated__variance = $generated__variance;
            this.x = x;
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            { // Code generated by: (x, mean, variance) { -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue }
              // Construction and addition of the factor/model:
              components.add(
                $generated__0_lazy(x, $generated__mean, $generated__variance)
              );
            }
            
            return components;
          }
        }
        '''
        )
    }
}
