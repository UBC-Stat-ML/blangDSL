package ca.ubc.stat.blang.tests.generate

import ca.ubc.stat.blang.tests.BlangDslInjectorProvider
import com.google.inject.Inject
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.TemporaryFolder
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.xbase.compiler.CompilationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(XtextRunner)
@InjectWith(BlangDslInjectorProvider)
class LoopGeneratorTest {
    @Inject public TemporaryFolder temporaryFolder
    @Inject extension CompilationTestHelper
        
    
    @Test
    def void forLoop() {
        '''
            model {
                random java.util.Random rand
                
                laws {
                    for (int i : 0..<3) {
                        indicator(rand) { rand.nextInt(4) > /* i */ 2 }
                    }
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.Model;
        import blang.core.ModelComponent;
        import blang.core.SupportFactor;
        import blang.inits.Arg;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.Random;
        import org.eclipse.xtext.xbase.lib.ExclusiveRange;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          public static class Builder {
            @Arg
            public Random rand;
            
            public MyFile build() {
              // For each optional type, either get the value, or evaluate the ?: expression
              // Build the instance after boxing params
              return new MyFile(
                rand
              );
            }
          }
          
          private final Random rand;
          
          public Random getRand() {
            return rand;
          }
          
          /**
           * Auxiliary method generated to translate:
           * 0..<3
           */
          private static Iterable<Integer> $generated__0(final Random rand) {
            ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 3, true);
            return _doubleDotLessThan;
          }
          
          /**
           * Auxiliary method generated to translate:
           * { rand.nextInt(4) > 2 }
           */
          private static Boolean $generated__1(final Random rand) {
            int _nextInt = rand.nextInt(4);
            return Boolean.valueOf((_nextInt > 2));
          }
          
          /**
           * Auxiliary method generated to translate:
           * { rand.nextInt(4) > 2 }
           */
          private static SupportFactor $generated__1_lazy(final Random rand) {
            return new SupportFactor(() -> $generated__1(rand));
          }
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with a BlangVariable annotation
           *   - params additionally have a Param annotation
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@DeboxedName("rand") final Random rand) {
            this.rand = rand;
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            for (int i : $generated__0(rand)) {
              { // Code generated by: (rand) { rand.nextInt(4) > 2 }
                // Construction and addition of the factor/model:
                components.add(
                  $generated__1_lazy(rand)
                );
              }
            }
            
            return components;
          }
        }
        '''
        )
    }
    
    @Test
    def void nestedForLoops() {
        '''
            model {
                random java.util.Random rand
                
                laws {
                    for (int i : 0..<3) {
                        for (int j : 0..<3) {
                            indicator(rand) { rand.nextInt(4) > /* i + j */ 1 + 2 }
                        }
                    }
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.Model;
        import blang.core.ModelComponent;
        import blang.core.SupportFactor;
        import blang.inits.Arg;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.Random;
        import org.eclipse.xtext.xbase.lib.ExclusiveRange;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          public static class Builder {
            @Arg
            public Random rand;
            
            public MyFile build() {
              // For each optional type, either get the value, or evaluate the ?: expression
              // Build the instance after boxing params
              return new MyFile(
                rand
              );
            }
          }
          
          private final Random rand;
          
          public Random getRand() {
            return rand;
          }
          
          /**
           * Auxiliary method generated to translate:
           * 0..<3
           */
          private static Iterable<Integer> $generated__0(final Random rand) {
            ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 3, true);
            return _doubleDotLessThan;
          }
          
          /**
           * Auxiliary method generated to translate:
           * 0..<3
           */
          private static Iterable<Integer> $generated__1(final int i, final Random rand) {
            ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 3, true);
            return _doubleDotLessThan;
          }
          
          /**
           * Auxiliary method generated to translate:
           * { rand.nextInt(4) > 1 + 2 }
           */
          private static Boolean $generated__2(final Random rand) {
            int _nextInt = rand.nextInt(4);
            return Boolean.valueOf((_nextInt > (1 + 2)));
          }
          
          /**
           * Auxiliary method generated to translate:
           * { rand.nextInt(4) > 1 + 2 }
           */
          private static SupportFactor $generated__2_lazy(final Random rand) {
            return new SupportFactor(() -> $generated__2(rand));
          }
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with a BlangVariable annotation
           *   - params additionally have a Param annotation
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@DeboxedName("rand") final Random rand) {
            this.rand = rand;
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            for (int i : $generated__0(rand)) {
              for (int j : $generated__1(i, rand)) {
                { // Code generated by: (rand) { rand.nextInt(4) > 1 + 2 }
                  // Construction and addition of the factor/model:
                  components.add(
                    $generated__2_lazy(rand)
                  );
                }
              }
            }
            
            return components;
          }
        }
        ''')
    }
    
    @Test
    def void instantiatedDistribution() {
        '''
            import ca.ubc.stat.blang.tests.types.Real
            import ca.ubc.stat.blang.tests.types.Normal
            import java.util.List
            
            model {
                param Real m
                param Real v
                random List<Real> means

                
                laws {
                    for (int i : 0..<2) {
                        means.get(i) | m, v ~ Normal(m, v)
                    }
                }
            }
        '''.assertCompilesTo(
        '''
        import blang.core.DeboxedName;
        import blang.core.Model;
        import blang.core.ModelComponent;
        import blang.core.Param;
        import blang.inits.Arg;
        import ca.ubc.stat.blang.tests.types.Normal;
        import ca.ubc.stat.blang.tests.types.Real;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.List;
        import java.util.function.Supplier;
        import org.eclipse.xtext.xbase.lib.ExclusiveRange;
        
        @SuppressWarnings("all")
        public class MyFile implements Model {
          public static class Builder {
            @Arg
            public Real m;
            
            @Arg
            public Real v;
            
            @Arg
            public List<Real> means;
            
            public MyFile build() {
              // For each optional type, either get the value, or evaluate the ?: expression
              // Build the instance after boxing params
              return new MyFile(
                means, 
                () -> m, 
                () -> v
              );
            }
          }
          
          @Param
          private final Supplier<Real> $generated__m;
          
          public Real getM() {
            return $generated__m.get();
          }
          
          @Param
          private final Supplier<Real> $generated__v;
          
          public Real getV() {
            return $generated__v.get();
          }
          
          private final List<Real> means;
          
          public List<Real> getMeans() {
            return means;
          }
          
          /**
           * Auxiliary method generated to translate:
           * 0..<2
           */
          private static Iterable<Integer> $generated__0(final Real m, final Real v, final List<Real> means) {
            ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, 2, true);
            return _doubleDotLessThan;
          }
          
          /**
           * Auxiliary method generated to translate:
           * means.get(i)
           */
          private static Real $generated__1(final int i, final Real m, final Real v, final List<Real> means) {
            Real _get = means.get(i);
            return _get;
          }
          
          /**
           * Auxiliary method generated to translate:
           * m
           */
          private static Real $generated__2(final Real m, final Real v) {
            return m;
          }
          
          /**
           * Auxiliary method generated to translate:
           * m
           */
          private static Supplier<Real> $generated__2_lazy(final Supplier<Real> $generated__m, final Supplier<Real> $generated__v) {
            return () -> $generated__2($generated__m.get(), $generated__v.get());
          }
          
          /**
           * Auxiliary method generated to translate:
           * v
           */
          private static Real $generated__3(final Real m, final Real v) {
            return v;
          }
          
          /**
           * Auxiliary method generated to translate:
           * v
           */
          private static Supplier<Real> $generated__3_lazy(final Supplier<Real> $generated__m, final Supplier<Real> $generated__v) {
            return () -> $generated__3($generated__m.get(), $generated__v.get());
          }
          
          /**
           * Note: the generated code has the following properties used at runtime:
           *   - all arguments are annotated with a BlangVariable annotation
           *   - params additionally have a Param annotation
           *   - the order of the arguments is as follows:
           *     - first, all the random variables in the order they occur in the blang file
           *     - second, all the params in the order they occur in the blang file
           * 
           */
          public MyFile(@DeboxedName("means") final List<Real> means, @Param @DeboxedName("m") final Supplier<Real> $generated__m, @Param @DeboxedName("v") final Supplier<Real> $generated__v) {
            this.$generated__m = $generated__m;
            this.$generated__v = $generated__v;
            this.means = means;
          }
          
          /**
           * A component can be either a distribution, support constraint, or another model  
           * which recursively defines additional components.
           */
          public Collection<ModelComponent> components() {
            ArrayList<ModelComponent> components = new ArrayList();
            
            for (int i : $generated__0($generated__m.get(), $generated__v.get(), means)) {
              { // Code generated by: means.get(i) | m, v ~ Normal(m, v)
                // Construction and addition of the factor/model:
                components.add(
                  new Normal(
                    $generated__1(i, $generated__m.get(), $generated__v.get(), means), 
                    $generated__2_lazy($generated__m, $generated__v), 
                    $generated__3_lazy($generated__m, $generated__v)
                  )
                );
              }
            }
            
            return components;
          }
        }
        ''' 
        )
    }
    
}
