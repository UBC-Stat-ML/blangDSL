import blang.core.DeboxedName;
import blang.core.LogScaleFactor;
import blang.core.Model;
import blang.core.ModelBuilder;
import blang.core.ModelComponents;
import blang.core.Param;
import blang.core.RealVar;
import blang.inits.Arg;
import ca.ubc.stat.blang.StaticJavaUtils;
import java.util.function.Supplier;

@SuppressWarnings("all")
public class MyFile implements Model {
  public static class Builder implements ModelBuilder {
    @Arg
    public RealVar mean;
    
    @Arg
    public RealVar variance;
    
    @Arg
    public RealVar x;
    
    public MyFile build() {
      // For each optional type, either get the value, or evaluate the ?: expression
      final RealVar __mean = mean;
      final RealVar __variance = variance;
      final RealVar __x = x;
      // Build the instance after boxing params
      return new MyFile(
        __x, 
        () -> __mean, 
        () -> __variance
      );
    }
  }
  
  @Param
  private final Supplier<RealVar> $generated__mean;
  
  public RealVar getMean() {
    return $generated__mean.get();
  }
  
  @Param
  private final Supplier<RealVar> $generated__variance;
  
  public RealVar getVariance() {
    return $generated__variance.get();
  }
  
  private final RealVar x;
  
  public RealVar getX() {
    return x;
  }
  
  /**
   * Utility main method for posterior inference on this model
   */
  public static void main(final String[] arguments) {
    StaticJavaUtils.callRunner(Builder.class, arguments);
  }
  
  /**
   * Auxiliary method generated to translate:
   * { -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue }
   */
  private static Double $generated__0(final RealVar x, final RealVar mean, final RealVar variance) {
    double _doubleValue = x.doubleValue();
    double _doubleValue_1 = mean.doubleValue();
    double _minus = (_doubleValue - _doubleValue_1);
    double _multiply = ((-0.5) * _minus);
    double _power = Math.pow(_multiply, 2);
    double _doubleValue_2 = variance.doubleValue();
    return Double.valueOf((_power / _doubleValue_2));
  }
  
  /**
   * Auxiliary method generated to translate:
   * { -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue }
   */
  private static LogScaleFactor $generated__0_lazy(final RealVar x, final Supplier<RealVar> $generated__mean, final Supplier<RealVar> $generated__variance) {
    return () -> $generated__0(x, $generated__mean.get(), $generated__variance.get());
  }
  
  /**
   * Note: the generated code has the following properties used at runtime:
   *   - all arguments are annotated with a BlangVariable annotation
   *   - params additionally have a Param annotation
   *   - the order of the arguments is as follows:
   *     - first, all the random variables in the order they occur in the blang file
   *     - second, all the params in the order they occur in the blang file
   * 
   */
  public MyFile(@DeboxedName("x") final RealVar x, @Param @DeboxedName("mean") final Supplier<RealVar> $generated__mean, @Param @DeboxedName("variance") final Supplier<RealVar> $generated__variance) {
    this.$generated__mean = $generated__mean;
    this.$generated__variance = $generated__variance;
    this.x = x;
  }
  
  /**
   * A component can be either a distribution, support constraint, or another model  
   * which recursively defines additional components.
   */
  public ModelComponents components() {
    ModelComponents components = new ModelComponents();
    
    { // Code generated by: (x, mean, variance) { -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue }
      // Construction and addition of the factor/model:
      components.add(
        $generated__0_lazy(x, $generated__mean, $generated__variance),
        "(x, mean, variance) { -0.5 * (x.doubleValue - mean.doubleValue)**2 / variance.doubleValue }"
      );
    }
    
    return components;
  }
}
