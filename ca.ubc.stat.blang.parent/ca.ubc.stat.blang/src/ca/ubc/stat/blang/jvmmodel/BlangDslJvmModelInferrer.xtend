/*
 * generated by Xtext 2.9.1
 */
package ca.ubc.stat.blang.jvmmodel

import blang.core.Model
import ca.ubc.stat.blang.blangDsl.BlangModel
import ca.ubc.stat.blang.blangDsl.Param
import com.google.inject.Inject
import java.lang.reflect.ParameterizedType
import java.util.ArrayList
import java.util.Collection
import java.util.function.Supplier
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmVisibility
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import ca.ubc.stat.blang.blangDsl.ConstParam
import ca.ubc.stat.blang.blangDsl.LazyParam
import ca.ubc.stat.blang.blangDsl.LogScaleFactor
import ca.ubc.stat.blang.blangDsl.ModelParam
import ca.ubc.stat.blang.blangDsl.SupportFactor
import blang.prototype3.Real

/**
 * <p>Infers a JVM model from the source model.</p> 
 *
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class BlangDslJvmModelInferrer extends AbstractModelInferrer {

    /**
     * convenience API to build and initialize JVM types and their members.
     */
    @Inject extension JvmTypesBuilder

    /**
     * The dispatch method {@code infer} is called for each instance of the
     * given element's type that is contained in a resource.
     * 
     * @param element
     *            the model to create one or more
     *            {@link JvmDeclaredType declared
     *            types} from.
     * @param acceptor
     *            each created
     *            {@link JvmDeclaredType type}
     *            without a container should be passed to the acceptor in order
     *            get attached to the current resource. The acceptor's
     *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
     *            accept(..)} method takes the constructed empty type for the
     *            pre-indexing phase. This one is further initialized in the
     *            indexing phase using the closure you pass to the returned
     *            {@link org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor.IPostIndexingInitializing#initializeLater(org.eclipse.xtext.xbase.lib.Procedures.Procedure1)
     *            initializeLater(..)}.
     * @param isPreIndexingPhase
     *            whether the method is called in a pre-indexing phase, i.e.
     *            when the global index is not yet fully updated. You must not
     *            rely on linking using the index if isPreIndexingPhase is
     *            <code>true</code>.
     */
    def dispatch void infer(BlangModel model, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
        val className = model.eResource.URI.trimFileExtension.lastSegment
        acceptor.accept(model.toClass(className)) [
            if (model.name != null) {
                it.packageName = model.name;
            }
            
            it.superTypes += typeRef(Model)
            
            if (model.vars != null) {
                for (varDecl : model.vars.randomVars) {
                    members += varDecl.toField(varDecl.name, varDecl.type ) [
                        visibility = JvmVisibility.PUBLIC
                        it.final = true
                    ]
                }
                for (varDecl : model.vars.paramVars) {
                    members += varDecl.toField(varDecl.name, typeRef(Supplier, varDecl.type)) [
                        visibility = JvmVisibility.PUBLIC
                        it.final = true
                    ]
                }
                for (varDecl : model.vars.consts) {
                    members += varDecl.toField(varDecl.name, varDecl.type) [
                        visibility = JvmVisibility.DEFAULT
                        it.final = true
                        it.static = true
                        initializer = varDecl.right
                    ]
                }
            }
            
            if ((model.vars?.randomVars != null && !model.vars.randomVars.empty) ||
                (model.vars?.paramVars != null &&!model.vars.paramVars.empty)) {
                it.members += model.toConstructor [
                    visibility = JvmVisibility.PUBLIC
                    for (varDecl : model.vars?.randomVars) {
                        parameters += varDecl.toParameter(varDecl.name, varDecl.type)
                    }
                    for (varDecl : model.vars?.paramVars) {
                        parameters += varDecl.toParameter(varDecl.name, typeRef(Supplier, varDecl.type))
                    }
                    body = '''
                        «FOR varDecl : model.vars?.randomVars»
                            this.«varDecl.name» = «varDecl.name»;
                        «ENDFOR»
                        «FOR varDecl : model.vars?.paramVars»
                            this.«varDecl.name» = «varDecl.name»;
                        «ENDFOR»
                    '''
                ]
            }
            
            if (model.laws?.modelComponents != null && !model.laws.modelComponents.empty) {
            it.members += model.toMethod("components", typeRef(Collection, typeRef(blang.core.ModelComponent))) [
                visibility = JvmVisibility.PUBLIC
                body = '''
                    «typeRef(ArrayList, typeRef(blang.core.ModelComponent))» components = new «typeRef(ArrayList)»();
                    
                    «FOR i : 0..<model.laws.modelComponents.size»
                        components.add(«generateModelComponentInit(model.laws.modelComponents.get(i), i)»);
                    «ENDFOR»
                    
                    return components;
                '''
            ]
            
            for (componentCounter : 0..<model.laws.modelComponents.size) {
                var component = model.laws.modelComponents.get(componentCounter)
                switch(component) {
                    ModelParam:
                        for (paramCounter : 0 ..< component.right.param.size) {
                                it.members += generateModelComponentParamSupplier(component, componentCounter, paramCounter)
                        }
                    SupportFactor:
                        it.members += generateSupportFactor(component, componentCounter)
                    LogScaleFactor:
                        it.members += generateLogScaleFactor(component, componentCounter)
                    //default: throw new Exception("What to do: " + component.class)
                }
            }
            }
        ]
    }
    
    
    def dispatch generateModelComponentInit(ModelParam component, int modelCounter) {
        '''
            new «component.right.clazz.type.identifier»(
                «component.name»«
                FOR i : 0..<component.right.param.size»,
                new $Generated_SupplierSubModel«modelCounter»Param«i»(«
                    FOR j : 0..<component.deps.size SEPARATOR ", "»«
                        component.deps.get(j).init»«
                    ENDFOR
                    »)«
                ENDFOR
                »)
            '''
    }
    
    
    def dispatch generateModelComponentInit(SupportFactor component, int modelCounter) {
        '''new «typeRef(blang.core.SupportFactor).identifier»(new $Generated_SetupSupport«modelCounter»(«
                    FOR p : component.params SEPARATOR ", "»«
                      p»«
                    ENDFOR»))'''
    }
    
    def dispatch generateModelComponentInit(LogScaleFactor component, int modelCounter) {
        '''new $Generated_LogScaleFactor«modelCounter»(«
            FOR p : component.params SEPARATOR ", "»«
              p»«
            ENDFOR»)'''
    }
    
    def generateModelComponentParamSupplier(ModelParam component,
                                            int modelCounter,
                                            int paramCounter) {
        val dist = component.right.clazz.type
        val distClass = Class.forName(dist.identifier)
        val distCtors = distClass.constructors
        val distCtor = distCtors?.get(0)
        val paramType = distCtor.genericParameterTypes.get(paramCounter+1)
        val paramTypeArgs = (paramType as ParameterizedType).actualTypeArguments
        val Param param = component.right.param.get(paramCounter)
        val paramSupplierTypeRef = typeRef(Supplier, typeRef(paramTypeArgs.get(0).typeName))
        
        param.toClass("$Generated_SupplierSubModel" + modelCounter + "Param" + paramCounter) [
            it.superTypes += paramSupplierTypeRef
            it.static = true
            for (dep : component.deps) {
                it.members += param.toField(dep.name, dep.type) [
                    final = true
                ]
            }
            it.members += param.toConstructor [
                    visibility = JvmVisibility.PUBLIC
                    for (dep : component.deps) {
                        parameters += param.toParameter(dep.name, dep.type)
                    }
                    body = '''
                        «FOR dep : component.deps»
                            this.«dep.name» = «dep.name»;
                        «ENDFOR»
                    '''
                ]
            
            it.members += param.toMethod("get", typeRef(paramTypeArgs.get(0).typeName)) [
                annotations += annotationRef("java.lang.Override")
                switch(param) {
                    ConstParam:
                        body = '''return «param.id»;'''
                    LazyParam:
                        body = param.expr
                }
            ]
        ]
    }

    def generateSupportFactor(SupportFactor factor,
                              int modelCounter) {
        factor.toClass("$Generated_SetupSupport" + modelCounter) [
            it.superTypes += typeRef(blang.core.SupportFactor.Support)
            it.static = true
            
            for (p : factor.params) {
                it.members += factor.toField(p, typeRef(Supplier, typeRef(Real))) [
                    final = true
                ]
            }
                        
            it.members += factor.toConstructor [
                it.visibility = JvmVisibility.PUBLIC
                for (p : factor.params) {
                    parameters += factor.toParameter(p, typeRef(Supplier, typeRef(Real)))
                }
                body = '''
                «FOR p : factor.params»
                this.«p» = «p»;
                «ENDFOR»
                '''
            ]
            
            it.members += factor.expr.toMethod("inSupport", typeRef(boolean)) [
                annotations += annotationRef("java.lang.Override")
                body = '''
                return $inSupport(«
                    FOR p : factor.params SEPARATOR ", "»«
                      p».get()«
                    ENDFOR
                »);
                '''
            ]
            it.members += factor.expr.toMethod("$inSupport", typeRef(boolean)) [
                visibility = JvmVisibility.PRIVATE
                for (p : factor.params) {
                    parameters += factor.toParameter(p, typeRef(Real))
                }
                body = factor.expr
            ]
        ]
    }

    def generateLogScaleFactor(LogScaleFactor factor,
                              int modelCounter) {
        factor.toClass("$Generated_LogScaleFactor" + modelCounter) [
            it.superTypes += typeRef(blang.factors.LogScaleFactor)
            it.static = true
            
            for (p : factor.params) {
                it.members += factor.toField(p, typeRef(Supplier, typeRef(Real))) [
                    final = true
                ]
            }
            
            it.members += factor.toConstructor [
                it.visibility = JvmVisibility.PUBLIC
                for (p : factor.params) {
                    parameters += factor.toParameter(p, typeRef(Supplier, typeRef(Real)))
                }
                body = '''
                «FOR p : factor.params»
                this.«p» = «p»;
                «ENDFOR»
                '''
            ]
            
            it.members += factor.expr.toMethod("logDensity", typeRef(double)) [
                annotations += annotationRef("java.lang.Override")
                body = '''
                return $logDensity(«
                    FOR p : factor.params SEPARATOR ", "»«
                      p».get()«
                    ENDFOR
                »);
                '''
            ]
            it.members += factor.expr.toMethod("$logDensity", typeRef(double)) [
                visibility = JvmVisibility.PRIVATE
                for (p : factor.params) {
                    parameters += factor.toParameter(p, typeRef(Real))
                }
                body = factor.expr
            ]
        ]
    }
}
